libname mapa '/home/alansilva0/my_shared_file_links/alansilva0/Estatistica_Espacial';

proc gmap data=mapa.Populacao_goias map=mapa.goias(keep=x y codigo) all;
id codigo;
choro populacao / legend=legend1;
legend1 position=(middle right) across=1 mode=reserve label=(position=top j=c);
run;
quit;

data ocid;
codigo=520549;
v=1;
run;
proc gmap data=ocid map=mapa.goias(keep=x y codigo) all;
id codigo;
choro v / nolegend;
run;
quit;


/****************** criar vizinhos ***********************/

%let confile=vizinhos;
%let idvar=codigo;
proc sort data=mapa.goias(keep=x y &idvar) out=mymap2 nodupkey; by x y &idvar.;run;
data hashmap (keep=x y z &idvar.);
retain z;
set mymap2(where=(x NE . and y NE .));
by x y;
if first.x or first.y then z=1;
z=z+1;
run;
proc means data=hashmap noprint;
output out=maxz max(z)=mz; run;
/*put the maximum value of z into macro variable maxnb*/
data _null_;
set maxz;
call symputx("maxnb",mz);
run;
%put &maxnb;
proc sort data=mymap2; by &idvar.;run;
data nonb (keep=myid);
length x y z 8; format &idvar. 16.; /*use a format statement for character id
values*/
if _n_=1 then do;
/*this hash object holds a second copy of the entire map for comparison*/
declare hash fc(dataset: "hashmap");
fc.definekey("x","y","z");
fc.definedata("x","y","z","&idvar.");
fc.definedone();
call missing (x,y,z,&idvar.);
/*this hash object will hold the rook neighbors for each area: they have two
points in common*/
declare hash rook();
rook.definekey("&idvar.","myid");
rook.definedata("&idvar.","myid");
rook.definedone();
end;
/*this hash object holds the bishop neighbors for each area: they have a point
in common*/
declare hash bishop();
bishop.definekey("&idvar.","myid");
bishop.definedata("&idvar.","myid");
bishop.definedone();
foundnb="N";
do until (last.myid);
set mymap2 (keep=&idvar. x y rename=(&idvar.=myid x=myx y=myy) where=(myx NE .
and myy NE .)) end=eof;
by myid;
do n=1 to &maxnb.; /*this is max number of points in common =max z*/
rc=fc.find(key:myx, key:myy, key:n);
if rc=0 and myid NE &idvar. then do;
nbrc=bishop.check(key:&idvar, key:myid);
if nbrc=0 then do;
rc2=rook.add(key:&idvar, key:myid, data:&idvar, data:myid);
foundnb="Y";
end;
else rc1=bishop.add(key:&idvar, key:myid, data:&idvar, data:myid);
end;
end;*do &maxnb.;
end;*end DOW loop;
if foundnb="N" then output nonb;
if eof then rook.output(dataset:"&confile.");
run;
proc sort data=&confile.;by &idvar;run;
proc sql;select count(distinct &idvar) from &confile.;quit;

data a;set &confile.(rename=codigo=codigo1);
if codigo1=520870;
v='Vizinhos';
run;
proc gmap map=mapa.goias(keep=x y codigo) data=a(rename=myid=codigo) all;
choro v;
id codigo;
run;quit;

/************************criando matriz w ********************************/

proc sort data=vizinhos(keep=codigo) nodupkey out=tab;by codigo;run;
data tab;set tab;idi=_n_;run;
proc sort data=vizinhos;by codigo;run;
data tabmun;merge vizinhos tab;by codigo;run;
proc sort data=tabmun;by myid;run;
data tabmun;merge tabmun tab(rename=(idi=idj codigo=myid));by myid;run;
proc sort data=tabmun;by codigo;run;

proc sql noprint;
select max(idi) into:n from tabmun;
quit;
%put &n;
proc iml;
use tabmun var{idi idj};
read all;
n=&n;
w=j(n,n,0);
do h=1 to nrow(idi);                                                                                                                   
w[idi[h],idj[h]]=1;
end;
wpdr=j(n,n,0);                                                                                                                        
soma=j(n,1,0);                                                                                                                         
do i=1 to n;                                                                                                                           
do j=1 to n;                                                                                                                           
soma[i]=soma[i]+w[i,j];                                                                                                                 
end;                                                                                                                                    
end;                                                                                                                                    
do i=1 to n;                                                                                                                           
do j=1 to n;      
if soma[i]=0 then wpdr[i,j]=0;
else wpdr[i,j]=w[i,j]/soma[i];  
end;                                                                                                                                    
end; 
create matrizw from w;                                                                                                                  
append from w;                                                                                                                          
create matrizwpdr from wpdr;                                                                                                            
append from wpdr;                                                                                                                       
quit;

/***** Media Movel *****/
proc iml;    
use mapa.Populacao_goias var{Populacao};
read all into y; 
use matrizwpdr;                                                                                                                 
read all into wpdr;   
ym=y[+]/nrow(y); 
u=wpdr*y;
create ui from u[colname={MM}];                                                                                                                  
append from u;                                                                                                                          
quit;     
data Populacao_goias;merge mapa.Populacao_goias ui;run;
proc gmap data=Populacao_goias map=mapa.goias(keep=x y codigo) all;
id codigo;
choro MM / legend=legend1;
legend1 position=(middle right) across=1 mode=reserve label=(position=top j=c);
run;
quit;

data goias;set mapa.goias(keep=x y codigo);run;
%include '/home/alansilva0/my_shared_file_links/alansilva0/Estatistica_Espacial/moranscatterplot.sas';
%let codigo=codigo;
%moran(populacao_goias,populacao,Matrizwpdr,tipo=goias);
%moran(populacao_goias,MM,Matrizwpdr,tipo=goias);
%moran(populacao_goias,casa,Matrizwpdr,tipo=goias);
%include '/home/alansilva0/my_shared_file_links/alansilva0/Estatistica_Espacial/lisa.sas';
%lisa(populacao_goias,populacao,Matrizwpdr,tipo=goias);
%lisa(populacao_goias,MM,Matrizwpdr,tipo=goias);
%lisa(populacao_goias,casa,Matrizwpdr,tipo=goias);

/******* I de Moran Algebrico ****************/
proc iml;
use populacao_goias var {populacao};
read all into y;
use matrizwpdr;
read all into w;
n=nrow(y);

ybar=y[+]/n;
z=y-repeat(ybar,n,1);
zsq=z`*z; 

sumw=0; s1=0;
 do K=1 to n;
  do J=1 to n;
   if K <> J then do;
     sumw=sumw + w[K,J];
      s1=s1 + (w[K,J]+w[J,K])**2;
    end;
  end;
 end;
s1=s1/2;
s2=w[,+]+w[+,]`;
s2=s2`*s2;
sumw2=sumw*sumw;
I=0; C=0;
 do K=1 TO n;
  do j=1 TO n;
    if K <> j then do;
       I = I + w[K,j] * z[K]*z[j];
       C = C + w[K,j] * (y[K]-y[j])**2;
     end;
  end;
 end;
 I=(n/sumw)*(I/zsq);
 C=((n-1)/(2*sumw))*(c/zsq);
 print I C;
 *teste para I;
 expect=-1/(1-n);
 var=((n**2*s1-n*s2+3*sumw2)/(sumw2*n**2-1))-expect**2;
 zz=(I-expect)/sqrt(var);
 p_value_i1=1-probnorm(abs(zz));
 PRINT  'TESTE BASEADO EM NORMALIDADE (I):' p_value_i1;
 *teste para C;
 expect_=1.0;
 _var=((2*s1+s2)*(n-1)-4*sumw2)/(2*(n+1)*sumw2);
 _zz=(C-expect_)/sqrt(_var);
 p_value_c1=1-probnorm(abs(_zz));
PRINT  'TESTE BASEADO EM NORMALIDADE (C):' p_value_c1;
create statistics var{I C p_value_i1 p_value_c1};
 append;
quit;

proc iml;
use populacao_goias var {populacao};
read all into y;
use matrizwpdr;
read all into wpdr;
z=y-y[:];
print y z;
z2=z`*z;
print z2;
zw=z`*wpdr;
print zw;
zwz=z`*wpdr*z;
print zwz;
I=inv(z`*z)*z`*wpdr*z;
print I;
quit;

proc variogram data=populacao_goias outv=outv plots(only)=moran;
   *compute lagd=7 maxlag=10 autocorr(assum=random);
   coordinates xc=East yc=North;
   var populacao;
run;


%annomac;
proc sort data=mapa.goias(keep=x y codigo) out=goias;by codigo;run;
%centroid(goias,centroide_populacao_goias,codigo);
data anno;set centroide_populacao_goias;
function='label';
style='simplex';
text='C';/*left(put(codigo,$6.));*/
size=0.65;
color='green';
xsys='2';
ysys='2';
when='a';
run;
data a;codigo=10000;v=2;run;
title 'Centroides';
proc gmap data=a map=mapa.goias(keep=x y codigo) all;
id codigo;
choro v /anno=anno nolegend;
run;
quit;

proc sort data=goias(keep=codigo x y) out=go1;by codigo;run;
proc iml;
use go1;
read all var{codigo x y} into C;
id1=unique(C[,1]);
cntr=j(1,3,0);
create centroides_go from cntr[colname={"id" "x" "y"}];
do j=1 to ncol(id1);
val=id1[j];
*C1=C[loc(C[,1]=j),];
use go1;
read all var{codigo x y} into C1 where(codigo=val/* & x ^=.*/);
A=0;
Cx=0;
Cy=0;
n=nrow(C1);
do i=1 to n-1;
if C1[i+1,2]=. then do;i=n;end;
else do;
A=A+(C1[i,2]*C1[i+1,3]-C1[i+1,2]*C1[i,3]);
Cx=Cx+((C1[i,2]+C1[i+1,2])*(C1[i,2]*C1[i+1,3]-C1[i+1,2]*C1[i,3]));
Cy=Cy+((C1[i,3]+C1[i+1,3])*(C1[i,2]*C1[i+1,3]-C1[i+1,2]*C1[i,3]));
end;
end;
A=A/2;
Cx=Cx/(6*A);
Cy=Cy/(6*A);
*print A Cx Cy;
cntr[1]=val;cntr[2]=Cx;cntr[3]=Cy;
append from cntr;
end;
quit;
data anno;set centroides_go;
function='label';
style='simplex';
text='C';/*left(put(codigo,$6.));*/
size=0.65;
color='green';
xsys='2';
ysys='2';
when='a';
run;
data a;codigo=10000;v=2;run;
title 'Centroides';
proc gmap data=a map=mapa.goias(keep=x y codigo) all;
id codigo;
choro v /anno=anno nolegend;
run;
quit;

/*************** mapa dos quartis ****************/

ods output quantiles=quantil;
proc univariate data=Populacao_goias;
var populacao;
run;
data quantil;
set quantil;
if 5<=_n_<=7;
format estimate commax18.0;
est=putn(estimate,'commax18.0');
call symput('q'||trim(left(_n_)),estimate);
call symput('nq'||trim(left(_n_)),trim(left(est)));
run;
data Populacao_goias;
length q_pop $40.;
set Populacao_goias;
if populacao <=&q7 then do;q_pop="menor que &nq7";v=1;end;
if populacao<=&q6 and populacao > &q7 then do;q_pop="entre &nq7 e &nq6";v=2;end;
if populacao<=&q5 and populacao > &q6 then do;q_pop="entre &nq6 e &nq5";v=3;end;
if populacao > &q5 then do;q_pop="maior que &nq5";v=4;end;
format q_pop $40.;
label q_pop="Populacao" v="Populacao";
run;
proc freq data=Populacao_goias;tables q_pop;run;
proc sort data=Populacao_goias;by v;run;
proc format;
value pop 1="menor que &nq7" 2="entre &nq7 e &nq6" 3="entre &nq6 e &nq5" 4="maior que &nq5";
run;
goptions reset=all;
proc gmap data=Populacao_goias map=mapa.goias(keep=x y codigo) all;
id codigo;
choro v / legend=legend1;
legend1 position=(middle right) across=1 mode=reserve label=(position=top j=c);
format v pop.;
run;
quit;

proc univariate data=Populacao_goias;
var populacao;
output out=quintis pctlpts=20 to 80 by 20 pctlpre=p_;
run;
proc transpose data=quintis out=quintis;run;
data quintis;
set quintis;
format col1 commax18.0;
est=putn(col1,'commax18.0');
call symput('q'||trim(left(_n_)),col1);
call symput('nq'||trim(left(_n_)),trim(left(est)));
run;
data Populacao_goias;
length q_pop $40.;
set Populacao_goias;
if populacao <=&q1 then do;q_pop="menor que &nq1";v=1;end;
if populacao<=&q2 and populacao > &q1 then do;q_pop="entre &nq1 e &nq2";v=2;end;
if populacao<=&q3 and populacao > &q2 then do;q_pop="entre &nq2 e &nq3";v=3;end;
if populacao<=&q4 and populacao > &q3 then do;q_pop="entre &nq3 e &nq4";v=4;end;
if populacao > &q4 then do;q_pop="maior que &nq4";v=5;end;
format q_pop $40.;
label q_pop="Populacao" v="Populacao";
run;
proc freq data=Populacao_goias;tables q_pop;run;
proc sort data=Populacao_goias;by v;run;
proc format;
value pop 1="menor que &nq1" 2="entre &nq1 e &nq2" 3="entre &nq2 e &nq3" 4="entre &nq3 e &nq4"
5="maior que &nq4";
run;
goptions reset=all;
proc gmap data=Populacao_goias map=mapa.goias(keep=x y codigo) all;
id codigo;
choro v / legend=legend1;
legend1 position=(middle right) across=1 mode=reserve label=(position=top j=c);
format v pop.;
run;
quit;

/******************** far model *********************/

proc iml;
use Populacao_goias var {mm};
read all into y;
use matrizwpdr;
read all into w;
close matrizwpdr;
n=nrow(y);
I=I(n);
y=y-y[:];
start max_like(p) global (y, w, n, I);
lnl=-(n/2)*log((1/n)*(y-p*w*y)`*(y-p*w*y))+log(abs(det(I-p*w)));
return(lnl);
finish max_like;
p=0.01;
optn={1};
call nlpnra(rc,xr,"max_like",p,optn);
p=xr;print p;
sigma2=(1/n)*(y-p*w*y)`*(y-p*w*y);
detval=det(I-p*w);
loglik=-(n/2)*log(2*3.14159)-(1/2*sigma2)*((y-p*w*y)`*(y-p*w*y))-(n/2)*log(sigma2)
+log(detval);
yhat=p*w*y;
res=y-yhat;
rsqr1=res`*res;
rsqr2=y`*y;
rsqr=1-rsqr1/rsqr2;
varp=j(2,2,0);
b=I-p*W;
wb=W*inv(b);
term1=trace(inv(b`*b)*(W`*W));
varp[1,1]=term1+trace(w*inv(b)*w*inv(b));
varp[2,2]=n/(2*sigma2*sigma2);
varp[2,1]=-(1/sigma2)*(p*term1-trace(inv(b`*b)*w));
varp[1,2]=varp[2,1];
varp=inv(varp);
tstat=p/sqrt(varp[1,1]);
probt=2*(1-probt(abs(tstat),n-2));
print 'Rho' p tstat probt,,
sigma2 loglik;
create rho var{rsqr tstat probt p sigma2 loglik};
append;
create pred_res var{yhat res y};
append;
quit;


/********** sar model *********************/

proc gplot data=Populacao_goias;
plot mm*casa;
run;
quit;

proc iml;
use Populacao_goias var{populacao};
read all into y;
use Populacao_goias var {casa};
read all into x;
x=choose(x=.,0,x);
use matrizwpdr;
read all into w;
n=nrow(y);
eig=eigval(x`*x);
maxa=max(eig);
mina=min(eig);
IC=sqrt(maxa/mina);
l=j(n,1,1);
x=l||x;
B0=inv(x`*x)*x`*y;
e0=y-X*B0;
Bl=inv(x`*x)*x`*W*y;
el=W*y-X*Bl;
I=I(n);
free l;
start max_like(p) global (y,W,n,x,e0,el,I);
lnl=-(n/2)*log((1/n)*(e0-p*el)`*(e0-p*el))+log(abs(det(I-p*w)));
return(lnl);
finish max_like;
p=0.01;
optn={1};
call nlpnms(rc,xr,"max_like",p,optn);
p=xr;print p;
*p=0;
B=(B0-p*Bl);
sigma2=(1/n)*(e0-p*el)`*(e0-p*el);
yhat=p*w*y+x*B;
nvar=ncol(x);
res=y-yhat;
rsqr1=res`*res;
ym=y-y[:];
rsqr2=ym`*ym;
rsqr=1-rsqr1/rsqr2;print rsqr;
rsqradj=1-((n-1)/(n-nvar))*(1-rsqr);
fvar={'Modelo','Erro','Total'};
gl=j(3,1,0);
SQ=j(3,1,0);
QM=j(2,1,0);
gl[1]=nvar-1;
gl[3]=n-1;
gl[2]=gl[3]-gl[1];
SQ[3]=sum(ym#ym);
SQ[2]=sum(res#res);
SQ[1]=SQ[3]-SQ[2];
QM[1]=SQ[1]/gl[1];
QM[2]=SQ[2]/gl[2];
testeF=QM[1]/QM[2];
probf=1-probf(testef,gl[1],gl[2]);
print "Anova",,fvar gl SQ QM testeF probf;
create anova var{fvar gl SQ QM testeF probf};
append;
t=I-p*w;
ti=inv(t);
pterm = trace(W*ti*W*ti + W*ti*(W*ti)`);
xpx = j(nvar+2,nvar+2,0);
xpx[1:nvar,1:nvar] = (1/sigma2)*(x`*x);  
xpx[1:nvar,nvar+1] = (1/sigma2)*x`*W*ti*x*B;
xpx[nvar+1,1:nvar] = xpx[1:nvar,nvar+1]`;
xpx[nvar+1,nvar+1] = (1/sigma2)*B`*x`*ti`*W`*W*ti*x*B + pterm;
xpx[nvar+2,nvar+2] = n/(2*sigma2*sigma2);
xpx[nvar+1,nvar+2] = (1/sigma2)*trace(W*ti*ti`)+(1/sigma2*sigma2)*(B`*x`*ti`*w`*ti*x*B)
-(1/sigma2*sigma2)*(p*B`*x`*ti`*w`*w*ti*x*B)-(1/sigma2)*(p*trace(inv(t`*t)*w`*w))
-(1/sigma2*sigma2)*(B`*x`*w*ti*x*B);
xpx[nvar+2,nvar+1] = xpx[nvar+1,nvar+2];
xpxi = inv(xpx)*I(nvar+2);
tmp = vecdiag(xpxi[1:nvar+1,1:nvar+1]);
bvec=B//p;
do i=1 to nvar+1;
if tmp[i]<0 then do;
tmp[i]=tmp[i]*(-1);
end;
end;
tstat = bvec/(sqrt(tmp));
probt=2*(1-probt(abs(tstat),n-2));
detval = det(I-p*w);
eD = (I-p*w)*y-x*B;
tmp2 = 1/(2*sigma2);
epe = eD`*eD;
llike = -(n/2)*log(2*3.14159)-(n/2)*log(sigma2)-n/2+detval ;
tmp1=sqrt(tmp);
*AIC=-2*llike+2*(nvar+1); 
AIC=n*log(sum(res#res)/n)+2*(nvar+1); 
BIC=-2*llike+log(n)*(nvar+1);
/* testes heterocedasticidade */;
pi=res#res/sigma2;
B0i=inv(x`*x)*x`*pi;
e0i=pi-X*B0i;
Bli=inv(x`*x)*x`*W*pi;
eli=W*pi-X*Bli;
I=I(n);
start max_like(p_i) global (W,n,x,e0i,eli,I);
lnl=-(n/2)*log((1/n)*(e0i-p_i*eli)`*(e0i-p_i*eli))+log(abs(det(I-p_i*w)));
return(lnl);
finish max_like;
p_i=0.01;
optn={1};
call nlpnms(rc,xr,"max_like",p_i,optn);
p_i=xr;
Bi=(B0i-p_i*Bli);
pihat=p_i*w*pi+x*Bi;
meanpi=sum(pi)/n;
SQEi=(pihat-meanpi)`*(pihat-meanpi);
brus=SQEi/2;
pbrus=1-probchi(brus,nvar-1);
create brus var{brus nvar pbrus};
append;
use Populacao_goias var {casa};
read all into x;
x0=x#x;
nn=ncol(x);
if nn>1 then x1=j(nrow(x),comb(nn,2),0);
do i=1 to nn-1;
do j=i+1 to nn;
if nn<=3 then do;
x1[,i+j-2]=x[,i]#x[,j];
end;
if nn=4 & i=1  then do;
x1[,i+j-2]=x[,i]#x[,j];
end;
if nn=4 & i>1 & i<=3  then do;
x1[,i+j-1]=x[,i]#x[,j];
end;
if nn=5 & i=1 then do;
x1[,i+j-2]=x[,i]#x[,j];
end;
if nn=5 & i=2 then do;
x1[,i+j]=x[,i]#x[,j];
end;
if nn=5 & i>2 & i<=4  then do;
x1[,i+j+1]=x[,i]#x[,j];
end;
end;
end;
l=j(n,1,1);
if nn=1 then x=l||x||x0;
else x=l||x||x0||x1;
B0r=inv(x`*x)*x`*res;
e0r=res-x*B0r;
Blr=inv(x`*x)*x`*W*res;
elr=W*res-x*Blr;
I=I(n);
start max_like(pr) global (W,n,e0r,elr,I);
lnl=-(n/2)*log((1/n)*(e0r-pr*elr)`*(e0r-pr*elr))+log(abs(det(I-pr*w)));
return(lnl);
finish max_like;
pr=0.01;
optn={1};
call nlpnms(rc,xr,"max_like",pr,optn);
pr=xr;
Br=(B0r-pr*Blr);
reshat=pr*w*res+x*Br;
resr=res-reshat;
rsqr1r=resr`*resr;
resm=res-(sum(res)/n);
rsqr2r=resm`*resm;
rsqrr=1-rsqr1r/rsqr2r;
white=n*rsqrr;
param=(nvar*(nvar+1))/2;
probw=1-probchi(abs(white),param);
print "Parametros Estimados",,
{"Intercepto","casa","p"} bvec tmp1 tstat probt;
create par_reg var{bvec tmp1 tstat probt};
append;
create inf var{rsqr rsqradj sigma2 llike AIC BIC white param probw};
append;
create pred_res var{yhat res y};
append;
quit;

proc spatialreg data=Populacao_goias wmat=matrizwpdr;
model populacao=casa /type=sar method=newrap;
run;
quit;

data pred_res;merge pred_res Populacao_goias(keep=codigo);run;
proc reg data=Populacao_goias;
model populacao=casa;
output out=residuos_conv r=res p=predito;
run;
quit;
goptions reset=all;
proc gplot data=residuos_conv;
plot res*predito/ vref=0;
run;
quit;
proc gchart data=residuos_conv;
vbar3d res /space=0;
run;quit;
goptions reset=all;
proc gplot data=pred_res;
plot res*yhat/ vref=0;
run;
quit;
proc gchart data=pred_res;
vbar3d res /space=0;
run;quit;

data goias;set mapa.goias(keep=x y codigo);run;
%moran(residuos_conv,res,Matrizwpdr,tipo=goias);
%moran(pred_res,res,Matrizwpdr,tipo=goias);



/**** mess ****/

proc iml;
use Populacao_goias var{populacao};
read all into y;
use Populacao_goias var {casa};
read all into x;
x=choose(x=.,0,x);
use matrizwpdr;
read all into w;
nvar=ncol(x);
n=nrow(y);
nomes={Intercept casa alpha}`;
nq=15;
yi=j(n,nq,0);
Q1=1;
H=I(n)-X*inv(X`*X)*X`;

do i=1 to nq;
yi[,i]=(W**i)*(y);
Q1=Q1//fact(i);
end;

yMat=y||yi;
Q=inv(diag(Q1));
Z=Q*yMat`*H*yMat*Q;

do j=1 to nrow(z);
do h=1 to nrow(z);
if j=1 & h=1 then do;c1=j+h;c2=z[j,h];end;
else do;c1=c1//(j+h);c2=c2//z[j,h];end;
end;
end;
c=c1||c2;
call sort(c,{1,2});
_nc_=(unique(c[,1]));
cm=j(1,ncol(_nc_),0);
do j=1 to ncol(_nc_);
do i=1 to nrow(c);
if c[i,1]=_nc_[j] then cm[j]=cm[j]+c[i,2];
end;
end;
v=j(ncol(cm),1,0);
do i=1 to ncol(cm);
v[i]=i;
end;
v[ncol(cm)]=0;
v1=v;
v2=v;
v1[ncol(cm)]=0;
v1[ncol(cm)-1]=0;
call sort(v,{1});
call sort(v1,{1});
alpha1=-3;
converge=1;
criteria = 0.001;
iter = 1;
itermax = 100;
do while (converge > criteria & iter < itermax);
v3=j(ncol(cm)-2,1,0);
v4=j(ncol(cm)-3,1,0);
do i=1 to ncol(cm)-2;
v3[i]=alpha1**(i);
end;
do i=1 to ncol(cm)-3;
v4[i]=alpha1**(i);
end;
v3=j(2,1,1)//v3;
v4=j(3,1,1)//v4;
alpha=alpha1-((cm*(v#v3))/(cm*(v#v1#v4)));
converge=abs(alpha-alpha1);
print iter alpha1 alpha;
alpha1=alpha;
iter = iter + 1;
end;
rho=1-exp(alpha);
print alpha rho;

quit;

/**************** sem model **********************/

proc iml;
use Populacao_goias var{populacao};
read all into y;
use Populacao_goias var {casa};
read all into x;
x=choose(x=.,0,x);
use Matrizwpdr;
read all into w;
n=nrow(y);
I=I(n);
l=j(n,1,1);
x=l||x;
nvar=ncol(x);
* Estat�stica I de Moran;
b = inv(x`*x)*x`*y;
e = y - x*b;
epe = e`*e;
mi = (e`*W*e)/epe;
M = I - x*(inv(x`*x))*x`;
tmw = trace(M*W);
meani = tmw/(n-nvar);
vari =  trace((M*W)*(M*W`)) + trace((M*W)*(M*W)) + tmw*tmw;
vari = vari/((n-nvar)*(n-nvar+2));
vari = vari - meani*meani;
mis = (mi-meani)/sqrt(vari);
probm = 2*(1-probnorm(abs(mis)));
/* Estat�stica LM */;
b = inv(x`*x)*x`*y;
e = y-x*b;
sigma2 = (e`*e)/n;
t1 = trace((W+W`)*W);
lm1 = (e`*W*e)/sigma2;
lmerr = (lm1*lm1)*(1/t1);
problm = 1-probchi(lmerr,1);
/* Estat�stica LR */;
b = inv(x`*x)*x`*y;
e0=y - x*b;
ed = y - x*b;
econverge = eD;
criteria = 0.001;
converge = 1;
iter = 1;
itermax = 100;
p=0.01;
do while (converge > criteria & iter < itermax);
start max_like(p) global (ed, w, I, n);
lnl=-(n/2)*log((1/n)*ed`*(I-p*w)`*(I-p*w)*ed)+log(abs(det(I-p*w)));
return(lnl);
finish max_like;
optn={1};
call nlpnra(rc,xr,"max_like",p,optn);
p=xr;
xs = x - p*W*x;
ys = y - p*W*y;
begls = inv(xs`*xs)*(xs`*ys);
eD = y - x*begls;
converge = max(abs(eD - econverge));
econverge = eD;
iter = iter + 1;
end;
l=xr;

xs = x - l*W*x;
ys = y - l*W*y;
begls = inv(xs`*xs)*(xs`*ys);
eD = y - x*begls;
Be = (I - l*W)*eD;
epe = Be`*Be;
sig1 =(1/n)*epe;
epe0 = e0`*e0;
sig0 = epe0/n;

*Estat�stica LM error para correla��o espacial dos res�duos em um Modelo SAR;
B0=inv(x`*x)*x`*y;
e0=y-X*B0;
Bl=inv(x`*x)*x`*W*y;
el=W*y-X*Bl;
I=I(n);
start max_like(p) global (y,W,n,x,e0,el,I);
lnl=-(n/2)*log((1/n)*(e0-p*el)`*(e0-p*el))+log(abs(det(I-p*w)));
return(lnl);
finish max_like;
p=0.01;
optn={1};
call nlpnms(rc,xr,"max_like",p,optn);
p=xr;
B=(B0-p*Bl);
sigma2=(1/n)*(e0-p*el)`*(e0-p*el);
yhat=p*w*y+x*B;
e=y-yhat;
t=I-p*w;
ti=inv(t);
pterm = trace(W*ti*W*ti + W*ti*(W*ti)`);
xpx = j(nvar+2,nvar+2,0);
xpx[1:nvar,1:nvar] = (1/sigma2)*(x`*x);  
xpx[1:nvar,nvar+1] = (1/sigma2)*x`*W*ti*x*B;
xpx[nvar+1,1:nvar] = xpx[1:nvar,nvar+1]`;
xpx[nvar+1,nvar+1] = (1/sigma2)*B`*x`*ti`*W`*W*ti*x*B + pterm;
xpx[nvar+2,nvar+2] = n/(2*sigma2*sigma2);
xpx[nvar+1,nvar+2] = (1/sigma2)*trace(W*ti*ti`)+(1/sigma2*sigma2)*(B`*x`*ti`*w`*ti*x*B)
-(1/sigma2*sigma2)*(p*B`*x`*ti`*w`*w*ti*x*B)-(1/sigma2)*(p*trace(inv(t`*t)*w`*w))
-(1/sigma2*sigma2)*(B`*x`*w*ti*x*B);
xpx[nvar+2,nvar+1] = xpx[nvar+1,nvar+2];
xpxi = inv(xpx)*I(nvar+2);
tmp = vecdiag(xpxi[1:nvar+1,1:nvar+1]);
rhot = tmp[nvar+1,1];
varr = rhot*rhot;
A = I-p*W;
AI = inv(A);
W2 =W;
T22 = trace(W2*W2 + W2`*W2);
T21 = trace(W2*W*AI + W2`*W*AI);
lm1 = (e`*W2*e)/sigma2;
Tterm = (T22 - T21*T21*varr);
TI = inv(Tterm);
lratio = lm1*lm1*TI;
problr = 1-probchi(lratio,1);

* Estat�stica Wald;
z = I-W;
z = I-l*W;
zi = inv(z);
t1 = trace(W*z);
t2 = trace(W*z)**2;
t3 = trace((W*z)`*(W*z));
walds = (l**2) *(t2 + t3 - (1/n)*(t1*t1));
probw = 1-probchi(walds,1);
create testes_espac var{mi mis probm lmerr problm lratio problr walds probw };
append;

* Estimando o Modelo;
b = inv(x`*x)*x`*y;
ed = y - x*b;
econverge = eD;
criteria = 0.001;
converge = 1;
iter = 1;
itermax = 100;
p=0.01;
do while (converge > criteria & iter < itermax);
start max_like(p) global (ed, w, I, n);
lnl=-(n/2)*log((1/n)*ed`*(I-p*w)`*(I-p*w)*ed)+log(abs(det(I-p*w)));
return(lnl);
finish max_like;
optn={1};
call nlpnra(rc,xr,"max_like",p,optn);
p=xr;
xs = x - p*W*x;
ys = y - p*W*y;
begls = inv(xs`*xs)*(xs`*ys);
eD = y - x*begls;
converge = max(abs(eD - econverge));
econverge = eD;
iter = iter + 1;
end;
p=xr;
xs = x - p*W*x;
ys = y - p*W*y;
begls = inv(xs`*xs)*(xs`*ys);
eD = y - x*begls;
yhat=x*begls;
res=y-yhat;
ym = y - y[:];
rsqr1 = epe;
rsqr2 = ym`*ym;
rsqr = 1 - rsqr1/rsqr2;
rsqr1 = rsqr1/(n-nvar);
rsqr2 = rsqr2/(n-1);
rsqradj = 1 - (rsqr1/rsqr2);
fvar={'Modelo','Erro','Total'};
gl=j(3,1,0);
SQ=j(3,1,0);
QM=j(2,1,0);
gl[1]=nvar-1;
gl[3]=n-1;
gl[2]=gl[3]-gl[1];
SQ[3]=sum(ym#ym);
SQ[2]=sum(res#res);
SQ[1]=SQ[3]-SQ[2];
QM[1]=SQ[1]/gl[1];
QM[2]=SQ[2]/gl[2];
testeF=QM[1]/QM[2];
probf=1-probf(testef,gl[1],gl[2]);
create anova var{fvar gl SQ QM testeF probf};
append;
Be = (I - p*W)*eD;
epe = Be`*Be;
sigma2_ =(1/n)*epe;
B = (I - p*W);
BI = inv(B); WB = W*BI;
pterm = trace(WB`*WB);
nvar=ncol(x);
xpx = j(nvar+2,nvar+2,0);
xpx[1:nvar,1:nvar] = (1/sigma2_)*x`*B`*B*x;  
xpx[nvar+1,nvar+1] = trace(WB*WB) + pterm;
xpx[nvar+2,nvar+2] = n/(2*sigma2_*sigma2_);
xpx[nvar+1,nvar+2] = -(1/sigma2_)*(p*trace(WB`*WB) - trace(BI`*WB));
xpx[nvar+2,nvar+1] = xpx[nvar+1,nvar+2];
tmp = vecdiag(inv(xpx));
bvec = begls//p;
tmp=remove(tmp,nvar+2);
tmp1=tmp`;
do i=1 to nvar+1;
if tmp1[i]<0 then do;
tmp1[i]=tmp1[i]*(-1);
end;
end;
tstat = bvec/(sqrt(tmp1));
tmp1=sqrt(tmp1);
probt=2*(1-probt(abs(tstat),n-2));
g=abs(det(I-p*W));
if g=0 then g=10**(-40); 
llike = -(n/2)*log(2*3.14159)-(n/2)*log(sigma2_)-n/2+log(g);
AIC=n*log(sum(res#res)/n)+2*(nvar+1); 
BIC=-2*llike+log(n)*(nvar+1);

create par_reg var{bvec tmp1 tstat probt};
append;
create inf var{rsqr rsqradj sigma2 llike AIC BIC};
append;
create pred_res var{yhat res y};
append;
quit;
data pred_res;merge pred_res Populacao_goias(keep=codigo);run;
goptions reset=all;
proc gplot data=pred_res;
plot res*yhat/ vref=0;
run;
quit;
proc gchart data=pred_res;
vbar3d res /space=0;
run;quit;
%moran(pred_res,res,Matrizwpdr,tipo=goias);

proc spatialreg data=Populacao_goias wmat=matrizwpdr method=quanew;
model populacao=casa /type=linear;
run;
quit;
proc reg data=Populacao_goias;
model populacao=casa;
run;
quit;


proc iml;
use Centroides_go;
read all var{x y} into COORD;
n=nrow(coord[,1]);
print n;
d=j(1,3,0);                                                                                                                             
nome={"idi" "idj" "d"};                                                                                                                 
create dist from d[colname=nome];                                                                                                       
do i=1 to n;
	do j=i+1 to n;
	if abs(coord[,1])<180 then do;
		dif=abs(COORD[i,1]-COORD[j,1]);
		raio=arcos(-1)/180;                                                                                                              
		if dif=0 then arco=0;
		else
		/* Law of Cosines */  
		arco=arcos(sin(COORD[i,2]*raio)*sin(COORD[j,2]*raio)+cos(COORD[i,2]*raio)*cos(COORD[j,2]*raio)*cos(dif*raio));
		d[1]=i;  
		d[2]=j;
		d[3]=arco*6371 /*Earth's Radius = 6371 (aproximately)*/;
		append from d;
	end;
	else do;
		d[1]=i;  
		d[2]=j;
		d[3]=sqrt((COORD[i,1]-COORD[j,1])**2+(COORD[i,2]-COORD[j,2])**2);   
		append from d;
	end;
	end;
end;
close dist;
quit;

proc iml;
use dist var{idi idj d};
read all;
n=242;
w=j(n,n,0);
do h=1 to nrow(idi);                                                                                                                   
w[idi[h],idj[h]]=1/d[h];
w[idj[h],idi[h]]=1/d[h];
end;

wpdr=j(n,n,0);                                                                                                                        
soma=j(n,1,0);                                                                                                                         
do i=1 to n;                                                                                                                           
do j=1 to n;                                                                                                                           
soma[i]=soma[i]+w[i,j];                                                                                                                 
end;                                                                                                                                    
end;                                                                                                                                    
do i=1 to n;                                                                                                                           
do j=1 to n;      
if soma[i]=0 then wpdr[i,j]=0;
else wpdr[i,j]=w[i,j]/soma[i];  
end;                                                                                                                                    
end; 
create matrizw from w;                                                                                                                  
append from w;                                                                                                                          
create matrizwpdr_dist from wpdr;                                                                                                            
append from wpdr;                                                                                                                       
quit;




/*********** modelo geral ******************/
proc iml;
use Populacao_goias var{mm};
read all into y;
use Populacao_goias var {casa};
read all into x;
x=choose(x=.,0,x);
use matrizwpdr;
read all into w1;
use matrizwpdr_dist;
read all into w2;
*w2=w1;
n=nrow(y);
I=I(n);
l=j(n,1,1);
x=l||x;
nvar=ncol(x);
start max_like(parm) global(I,n,y,x,W1,W2);
z1=(I-parm[1,1]*W1);
z2=(I-parm[1,2]*W2);
b=inv(x`*z1`*z1*x)*(x`*z1`*z1*z2*y);
ed=z2*y-x*b;
epe =ed`*z1`*z1*ed; 
lnl = -(n/2)*log(epe/n) + log(abs(det(I-parm[1,1]*w1)))
+ log(abs(det(I-parm[1,2]*w2)));
return(lnl);
finish max_like;
parm={0.01 0.01};
optn={1};
call nlpnra(rc,xr,"max_like",parm,optn);
p=xr[1,1];
l=xr[1,2];
A = I-p*W1;
B = I-l*W2;
b0= inv(x`*B`*B*x)*(x`*B`*B*A*y);
e = B*A*y-B*x*b0;
yhat =y-e;
res=y-yhat;
sigu = e`*e;
sigma2 = sigu/n;
ym=y-y[:];
rsqr1=sigu;
rsqr2=ym`*ym;
rsqr=1-rsqr1/rsqr2;
rsqr1=rsqr1/(n-nvar);
rsqr2=rsqr2/(n-1);
rsqradj=1-(rsqr1/rsqr2); 
fvar={'Modelo','Erro','Total'};
gl=j(3,1,0);
SQ=j(3,1,0);
QM=j(2,1,0);
gl[1]=nvar-1;
gl[3]=n-1;
gl[2]=gl[3]-gl[1];
SQ[3]=sum(ym#ym);
SQ[2]=sum(res#res);
SQ[1]=SQ[3]-SQ[2];
QM[1]=SQ[1]/gl[1];
QM[2]=SQ[2]/gl[2];
testeF=QM[1]/QM[2];
probf=1-probf(testef,gl[1],gl[2]);
create anova var{fvar gl SQ QM testeF probf};
append;
xpx = j(nvar+3,nvar+3,0);
BI = inv(B); AI = inv(A); WB = W2*BI; WA = W1*AI;
xpx[1:nvar,1:nvar] = (1/sigma2)*(x`*B`*B*x);
term1 = trace(WA*WA);
term2 = (1/sigma2)*trace(W1`*B`*B*WA*(x*b0)*(x*b0)`*AI`);
term3 = trace(W1`*B`*B*W1*inv(B*A)`);
xpx[nvar+1,nvar+1] = term1+term2+term3;
term1 = trace(WB*WB);
term2 = trace(WB`*WB);
xpx[nvar+2,nvar+2] = term1+term2;
xpx[nvar+3,nvar+3] = n/(2*sigma2**2);
xpx[1:nvar,nvar+1] = (1/sigma2)*(x`*B`*B*WA*x*b0);
xpx[nvar+1,1:nvar] = xpx[1:nvar,nvar+1]`;
xpx[nvar+2,1:nvar] = j(1,nvar,0);
xpx[1:nvar,nvar+2] = xpx[nvar+2,1:nvar]`;
xpx[nvar+3,nvar+1] = (1/sigma2)*trace(W1*AI);
xpx[nvar+1,nvar+3] = xpx[nvar+3,nvar+1];
xpx[nvar+3,nvar+2] = (1/sigma2)*trace(W2*BI);
xpx[nvar+2,nvar+3] = xpx[nvar+3,nvar+2];
term1 = trace(W1`*W2*inv(B*A)`);
term2 = trace(W2`*B*WA*inv(B`*B));
xpx[nvar+1,nvar+2] = term1+term2;
xpx[nvar+2,nvar+1] = xpx[nvar+1,nvar+2];
tmp = vecdiag(inv(xpx));
tmp=remove(tmp,nvar+3);
tmp1=tmp`;
bvec=b0//p//l;
do i=1 to nvar+2;
if tmp1[i]<0 then do;
tmp1[i]=tmp1[i]*(-1);
end;
end;
tstat = bvec/sqrt(tmp1);
tmp1=sqrt(tmp1);
probt=2*(1-probt(abs(tstat),n-2));
llike = -(n/2)*(1+log(2*3.14159))-(n/2)*log(sigma2)+log(abs(det(I-p*W1)))
+log(abs(det(I-l*W2)));
AIC=n*log(sum(res#res)/n)+2*(nvar+1); 
BIC=-2*llike+log(n)*(nvar+2);
create par_reg var{bvec tmp1 tstat probt};
append;
create inf var{rsqr rsqradj sigma2 llike AIC BIC};
append;
create pred_res var{yhat res y};
append;
quit;
data pred_res;merge pred_res Populacao_goias(keep=codigo);run;
goptions reset=all;
proc gplot data=pred_res;
plot res*yhat/ vref=0;
run;
quit;
proc gchart data=pred_res;
vbar3d res /space=0;
run;quit;
%moran(pred_res,res,Matrizwpdr,tipo=goias);


/*************** durbin model *************************/

proc iml;
use Populacao_goias var{populacao};
read all into y;
use Populacao_goias var {casa};
read all into x;
x=choose(x=.,0,x);
use matrizwpdr;
read all into w;
n=nrow(y);
l=j(n,1,1);
wx=w*x;
x=l||x||wx;
B0=inv(x`*x)*x`*y;
e0=y-X*B0;
Bl=inv(x`*x)*x`*W*y;
el=W*y-X*Bl;
I=I(n);
nvar=ncol(x);
start max_like(p) global (y, w , I, el, e0, n);
lnl=-(n/2)*log((1/n)*(e0-p*el)`*(e0-p*el))+log(abs(det(I-p*w)));
return(lnl);
finish max_like;
p=0.01;
optn={1};
call nlpnms(rc,xr,"max_like",p,optn);
p= xr;
B=(B0-p*Bl);
sigma2=(1/n)*(e0-p*el)`*(e0-p*el);
yhat=p*w*y+x*B;
res=y-yhat;
rsqr1=res`*res;
ym=y-y[:];
rsqr2=ym`*ym;
rsqr=1-rsqr1/rsqr2;
rsqr1=rsqr1/(n-2*nvar+1);
rsqr2=rsqr2/(n-1);
rsqradj=1-(rsqr1/rsqr2);
fvar={'Modelo','Erro','Total'};
gl=j(3,1,0);
SQ=j(3,1,0);
QM=j(2,1,0);
gl[1]=nvar-1;
gl[3]=n-1;
gl[2]=gl[3]-gl[1];
SQ[3]=sum(ym#ym);
SQ[2]=sum(res#res);
SQ[1]=SQ[3]-SQ[2];
QM[1]=SQ[1]/gl[1];
QM[2]=SQ[2]/gl[2];
testeF=QM[1]/QM[2];
probf=1-probf(testef,gl[1],gl[2]);
create anova var{fvar gl SQ QM testeF probf};
append;
t=I-p*w;
ti=inv(t);
nvar=ncol(x);
pterm = trace(W*ti*W*ti + W*ti*(W*ti)`);
xpx = j(nvar+2,nvar+2,0);
xpx[1:nvar,1:nvar] = (1/sigma2)*(x`*x);  
xpx[1:nvar,nvar+1] = (1/sigma2)*x`*W*ti*x*B;
xpx[nvar+1,1:nvar] = xpx[1:nvar,nvar+1]`;
xpx[nvar+1,nvar+1] = (1/sigma2)*B`*x`*ti`*W`*W*ti*x*B + pterm;
xpx[nvar+2,nvar+2] = n/(2*sigma2*sigma2);
xpx[nvar+1,nvar+2] = (1/sigma2)*trace(W*ti*ti`)+(1/sigma2*sigma2)*(B`*x`*ti`*w`*ti*x*B)
-(1/sigma2*sigma2)*(p*B`*x`*ti`*w`*w*ti*x*B)-(1/sigma2)*(p*trace(inv(t`*t)*w`*w))
-(1/sigma2*sigma2)*(B`*x`*w*ti*x*B);
xpx[nvar+2,nvar+1] = xpx[nvar+1,nvar+2];
xpxi = inv(xpx)*I(nvar+2);
tmp = vecdiag(xpxi[1:nvar+1,1:nvar+1]);
bvec=B//p;
do i=1 to nvar+1;
if tmp[i]<0 then do;
tmp[i]=tmp[i]*(-1);
end;
end;
tstat = bvec/(sqrt(tmp));
tmp1=sqrt(tmp);
probt=2*(1-probt(abs(tstat),n-2));
detval = det(I-p*w);
eD = (I-p*w)*y-x*B;
tmp2 = 1/(2*sigma2);
epe = eD`*eD;
llike = -(n/2)*log(2*3.14159)-(n/2)*log(sigma2)-n/2+detval ;
AIC=n*log(sum(res#res)/n)+2*(nvar+1); 
BIC=-2*llike+log(n)*(nvar+1);
create par_reg var{bvec tmp1 tstat probt};
append;
create inf var{rsqr rsqradj sigma2 llike AIC BIC};
append;
create pred_res var{yhat res y};
append;
quit;

/************************** GWR **************************************/

%include 'C:\Disciplinas\IntrAnalisedadosespaciais\colorscaleMACRO.sas';
%include 'C:\Disciplinas\IntrAnalisedadosespaciais\GWR_SAS.sas';
data coord_goias;set mapa.coordenadas;where uf='GO';run;
proc iml;
use coord_goias;
read all var{x y} into COORD;
n=nrow(coord[,1]);
*print n;
d=j(1,3,0);                                                                                                                             
nome={"idi" "idj" "d"};                                                                                                                 
create dist from d[colname=nome];                                                                                                       
do i=1 to n;
	do j=i+1 to n;
	if abs(coord[,1])<180 then do;
		dif=abs(COORD[i,1]-COORD[j,1]);
		raio=arcos(-1)/180;                                                                                                              
		if dif=0 then arco=0;
		else
		/* Law of Cosines */  
		arco=arcos(sin(COORD[i,2]*raio)*sin(COORD[j,2]*raio)+cos(COORD[i,2]*raio)*cos(COORD[j,2]*raio)*cos(dif*raio));
		d[1]=i;  
		d[2]=j;
		d[3]=arco*6371 /*Earth's Radius = 6371 (aproximately)*/;
		append from d;
	end;
	else do;
		d[1]=i;  
		d[2]=j;
		d[3]=sqrt((COORD[i,1]-COORD[j,1])**2+(COORD[i,2]-COORD[j,2])**2);   
		append from d;
	end;
	end;
end;
close dist;
quit;
proc means data=dist;var d;run;

/******* METHOD FIXED *****************/
%Golden(DATA=Populacao_goias,YVAR=MM,XVAR=casa,DCOORD=coord_goias,
OUTPUT=band,MINV=0,MIDDLEV=430,MAXV=869,METHOD=FIXED);


proc gplot data=band;
plot cv1*h1 cv2*h2 /overlay;
symbol1 i=none v=dot c=blue;
symbol2 i=none v=dot c=red;
run;
quit;

%GWR(DATA=Populacao_goias,YVAR=MM,XVAR=casa,DCOORD=coord_goias,DHV=,
MAXV=869,METHOD=FIXED,H=200);
/*
%include 'C:\Estagio_Probatorio\Pos_doutorado\dados\GWR_SAS_survey.sas' /lrecl=32767;
%GWR(DATA=Populacao_goias,YVAR=MM,XVAR=casa,DCOORD=coord_goias,DHV=,MAXV=869,
METHOD=FIXED_G,H=100);
 */

%MAP(DCOORD=coord_goias,GEOVAR=codigo,DMAP=mapa.goias,DMAP2=,PAR=1);
proc means data=b0 min median mean max;var b;run;
proc means data=b1 min median mean max;var b;run;
data b0;set b0;
ctlink='ALT="Codigo: '||trim(left(codigo))||"0D"x||'B0: '||trim(left(b))||'"';
run;

proc reg data=Populacao_goias;
model MM=casa;
run;
quit;

filename odsout 'C:\Disciplinas\IntrAnalisedadosespaciais';
ods html path=odsout file='goias_B0.html';
title1 h=14pt f=swissb "GWR Estimates";
proc gmap data=b0 map=mapa.goias all;
	 id codigo;
	 choro B /cempty=black coutline=black legend=legend1 html=ctlink;
	 format B comma20.2;
	 legend1 position=(middle right) across=1 mode=reserve label=("B0" position=top j=c);
	run;
ods html close;
ods listing;

%macro c;
proc sql noprint;select n(i) into:nc from l2;quit;
data l2;set l2;
if i='Low-Low' then c='pink';
if i='High-High' then c='red';
if i='High-Low' then c='blue';
if i='Low-High' then c='vpab';
call symput('c'||trim(left(_n_)),c);
run;
%do j=1 %to &nc;
pattern&j c=&&c&j;
%end;
%mend c;
%c;

data L1;merge L1 b0(keep=b codigo rename=b=b0) b1(keep=b codigo rename=b=b1);by codigo;
ctlink='ALT="Codigo: '||trim(left(codigo))||"0D"x||'B0: '||trim(left(b0))||
"0D"x||'B1: '||trim(left(b1))||'"';
if sig95='' then I2=I;else I2='';
run;
filename odsout 'C:\Disciplinas\IntrAnalisedadosespaciais';
ods html path=odsout file='LISA_GWR.html';
goptions reset=footnote;
goptions ftitle='Verdana' ftext='Verdana';
title1 "Moran Map (95%)";
proc gmap data=l1 map=mapa.goias all;
id codigo;
choro I2 / cempty=black html=ctlink;
run;
quit;
ods html close;
ods listing;



/******* METHOD ADAPTIVE1 *****************/
%Golden(DATA=Populacao_goias,YVAR=MM,XVAR=casa,DCOORD=coord_goias,
OUTPUT=band,MINV=0,MIDDLEV=430,MAXV=869,METHOD=ADAPTIVE1);
%GWR(DATA=Populacao_goias,YVAR=MM,XVAR=casa,DCOORD=coord_goias,DHV=,
MAXV=869,METHOD=ADAPTIVE1,H=);
%MAP(DCOORD=coord_goias,GEOVAR=codigo,DMAP=mapa.goias,DMAP2=,PAR=1);

/******* METHOD ADAPTIVEN *****************/
%Golden(DATA=Populacao_goias,YVAR=MM,XVAR=casa,DCOORD=coord_goias,
OUTPUT=band,MINV=0,MIDDLEV=430,MAXV=869,METHOD=ADAPTIVEN);
%GWR(DATA=Populacao_goias,YVAR=MM,XVAR=casa,DCOORD=coord_goias,DHV=,
MAXV=869,METHOD=ADAPTIVEN,H=);
%MAP(DCOORD=coord_goias,GEOVAR=codigo,DMAP=mapa.goias,DMAP2=,PAR=1);

data significativos;set l1;where sig95='';run;
proc sql;
select * from b0
where codigo in (select codigo from significativos);
select * from b1
where codigo in (select codigo from significativos);
quit;
